; ============================================================================
; AmeNoOhobari.asm - V.1.4.5 - The God-Slayer Chess Engine
; Author: Tonmoy KS
; Version: 1.4.5
;
; How to Compile and Run (on Linux):
;   nasm -f elf64 -g AmeNoOhobari.asm -o AmeNoOhobari.o
;   ld AmeNoOhobari.o -o AmeNoOhobari
;   ./AmeNoOhobari
;
; Expected Output: bestmove g1f3
; ============================================================================

section .data
EMPTY       equ 0; W_PAWN      equ 1; W_KNIGHT    equ 2; W_BISHOP    equ 3; W_ROOK      equ 4; W_QUEEN     equ 5; W_KING      equ 6
B_PAWN      equ 9; B_KNIGHT    equ 10; B_BISHOP    equ 11; B_ROOK      equ 12; B_QUEEN     equ 13; B_KING      equ 14
PIECE_MASK  equ 7; COLOR_MASK  equ 8

piece_values: dw 0, 100, 320, 330, 500, 900, 10000
passed_pawn_bonus: dw 0, 10, 30, 50, 75, 100, 150, 0
pst_pointers: dq pawn_pst, knight_pst, bishop_pst, rook_pst, queen_pst, king_pst

knight_offsets: db -17, -15, -10, -6, 6, 10, 15, 17
bishop_offsets: db -9, -7, 7, 9
rook_offsets:   db -8, -1, 1, 8
king_offsets:   db -9, -8, -7, -1, 1, 7, 8, 9

pawn_pst:
    db   0,   0,   0,   0,   0,   0,   0,   0,  50,  50,  50,  50,  50,  50,  50,  50
    db  10,  10,  20,  30,  30,  20,  10,  10,   5,   5,  10,  25,  25,  10,   5,   5
    db   0,   0,   0,  20,  20,   0,   0,   0,   5,  -5, -10,   0,   0, -10,  -5,   5
    db   5,  10,  10, -20, -20,  10,  10,   5,   0,   0,   0,   0,   0,   0,   0,   0
knight_pst:
    db -50, -40, -30, -30, -30, -30, -40, -50, -40, -20,   0,   0,   0,   0, -20, -40
    db -30,   0,  10,  15,  15,  10,   0, -30, -30,   5,  15,  20,  20,  15,   5, -30
    db -30,   0,  15,  20,  20,  15,   0, -30, -30,   5,  10,  15,  15,  10,   5, -30
    db -40, -20,   0,   5,   5,   0, -20, -40, -50, -40, -30, -30, -30, -30, -40, -50
bishop_pst:
    db -20, -10, -10, -10, -10, -10, -10, -20, -10,   0,   0,   0,   0,   0,   0, -10
    db -10,   0,   5,  10,  10,   5,   0, -10, -10,   5,   5,  10,  10,   5,   5, -10
    db -10,   0,  10,  10,  10,  10,   0, -10, -10,  10,  10,  10,  10,  10,  10, -10
    db -10,   5,   0,   0,   0,   0,   5, -10, -20, -10, -10, -10, -10, -10, -10, -20
rook_pst:
    db   0,   0,   0,   0,   0,   0,   0,   0,   5,  10,  10,  10,  10,  10,  10,   5
    db  -5,   0,   0,   0,   0,   0,   0,  -5,  -5,   0,   0,   0,   0,   0,   0,  -5
    db  -5,   0,   0,   0,   0,   0,   0,  -5,  -5,   0,   0,   0,   0,   0,   0,  -5
    db  -5,   0,   0,   0,   0,   0,   0,  -5,   0,   0,   0,   5,   5,   0,   0,   0
queen_pst:
    db -20, -10, -10,  -5,  -5, -10, -10, -20, -10,   0,   0,   0,   0,   0,   0, -10
    db -10,   0,   5,   5,   5,   5,   0, -10,  -5,   0,   5,   5,   5,   5,   0,  -5
    db   0,   0,   5,   5,   5,   5,   0,  -5, -10,   5,   5,   5,   5,   5,   0, -10
    db -10,   0,   5,   0,   0,   0,   0, -10, -20, -10, -10,  -5,  -5, -10, -10, -20
king_pst:
    db -30, -40, -40, -50, -50, -40, -40, -30, -30, -40, -40, -50, -50, -40, -40, -30
    db -30, -40, -40, -50, -50, -40, -40, -30, -30, -40, -40, -50, -50, -40, -40, -30
    db -20, -30, -30, -40, -40, -30, -30, -20, -10, -20, -20, -20, -20, -20, -20, -10
    db  20,  20,   0,   0,   0,   0,  20,  20,  20,  30,  10,   0,   0,  10,  30,  20

initial_board:
    db B_ROOK, B_KNIGHT, B_BISHOP, B_QUEEN, B_KING, B_BISHOP, B_KNIGHT, B_ROOK
    db B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN
    db 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0
    db W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN
    db W_ROOK, W_KNIGHT, W_BISHOP, W_QUEEN, W_KING, W_BISHOP, W_KNIGHT, W_ROOK

zobrist_keys:
    piece_keys: times 64 * 12 dq 0
    side_key: dq 0
opening_book_path: db "book.bin", 0
bestmove_msg: db "bestmove "
len_bestmove_msg: equ $ - bestmove_msg
newline: db 10
square_to_an: db "a1b1c1d1e1f1g1h1a2b2c2d2e2f2g2h2a3b3c3d3e3f3g3h3a4b4c4d4e4f4g4h4a5b5c5d5e5f5g5h5a6b6c6d6e6f6g6h6a7b7c7d7e7f7g7h7a8b8c8d8e8f8g8h8"
fen_pieces: db "PNBRQK  pnbrqk"
lcg_seed: dq 123456789123456789

section .bss
board: resb 64
side_to_move: resb 1
move_list: resb 256 * 4
move_list_end: resq 1
root_best_move: resd 1
nodes_searched: resq 1
move_scores: resd 256
opening_book: resb 16 * 1024 * 1024
book_size: resq 1
fen_buffer: resb 100
best_score_prev_iter: resd 1

section .text
extern probe_syzygy_wdl_from_fen
global _start

%macro ADD_MOVE 2
    mov rdi, [move_list_end]
    mov byte [rdi], %1; mov byte [rdi+1], %2; add rdi, 4; mov [move_list_end], rdi
%endmacro

_start:
    call initialize_engine
    call iterative_deepening
    call print_best_move
    mov rax, 60; xor rdi, rdi; syscall

initialize_engine:
    call initialize_board
    call initialize_zobrist_keys
    call load_opening_book
    ret

iterative_deepening:
    mov dword [best_score_prev_iter], 0
    mov ecx, 1
.depth_loop:
    cmp ecx, 6
    jg .id_done
    mov edx, [best_score_prev_iter]
    mov esi, edx; sub esi, 50; add edx, 50
    mov edi, ecx
    call search_root
    cmp eax, esi; jle .research_low
    cmp eax, edx; jge .research_high
    jmp .store_results
.research_low:
    mov esi, -30000; mov edi, ecx; call search_root; jmp .store_results
.research_high:
    mov edx, 30000; mov edi, ecx; call search_root
.store_results:
    mov [best_score_prev_iter], eax
    inc ecx; jmp .depth_loop
.id_done: ret

search_root:
    push r12; push r13; push r14; push r15
    mov r12d, esi; mov r13d, edx; mov r15, rdi; mov dword [root_best_move], 0
    mov qword [nodes_searched], 0
    call generate_moves; call score_moves
    mov r11, 0; mov r9d, -30001
.move_loop:
    mov r10, [move_list_end]; sub r10, move_list; shr r10, 2; cmp r11, r10
    jge .done_searching
    call find_next_best_move; movzx r8, byte [r10]; movzx r9b, byte [r10+1]
    call make_move
    mov rdi, r15; dec rdi; mov rsi, r13d; neg esi; mov rdx, r12d; neg edx
    call negamax; neg eax
    call unmake_move
    inc r11
    cmp eax, r12d; jle .next_move_in_loop
    mov r12d, eax; mov r9d, eax; mov cl, r8b; mov ch, r9b; mov [root_best_move], cx
.illegal_root_move:
    call unmake_move
    inc r11
    jmp .move_loop
.next_move_in_loop:
    jmp .move_loop
.done_searching:
    mov eax, r9d
    pop r15; pop r14; pop r13; pop r12; ret

negamax:
    push rbp; mov rbp, rsp; push r12; push r13; push r14; push r15; push rbx
    inc qword [nodes_searched]
    cmp rdi, 0; je .quiescence_search_entry
    mov r12d, esi; mov r13d, edx; mov r14, rdi; mov rbx, 0
    call generate_moves; call score_moves
    mov r15, 0; mov r8d, -30001
.move_loop_negamax:
    mov r10, [move_list_end]; sub r10, move_list; shr r10, 2; cmp r15, r10
    jge .done_searching_negamax
    call find_next_best_move
movzx ecx, byte[r10]; movzx edx, byte[r10+1]
call make_move
mov al, [side_to_move]
xor al, 8                   ; Temporarily flip side back
mov [side_to_move], al

call is_king_in_check       ; Is MY king in check after my move?

mov al, [side_to_move]
xor al, 8                   ; Flip side back to normal
mov [side_to_move], al

test al, al                 
jnz .illegal_move           

    cmp r15, 0; je .full_window_search
    mov esi, r12d; neg esi; dec esi; mov edx, esi; inc edx
    call negamax; neg eax
    cmp eax, r12d; jle .store_score; cmp eax, r13d; jge .store_score
.full_window_search:
    mov esi, r13d; neg esi; mov edx, r12d; neg edx
    call negamax; neg eax
.store_score:
    call unmake_move
    cmp eax, r8d; jle .next_move_negamax
    mov r8d, eax; mov r12d, eax
    cmp r12d, r13d; jge .beta_cutoff
.illegal_move:
    call unmake_move         
.next_move_negamax:
    inc r15; jmp .move_loop_negamax
.beta_cutoff: jmp .done_searching_negamax
.quiescence_search_entry: call quiescence_search; jmp .exit
.done_searching_negamax: mov eax, r8d
.exit: pop rbx; pop r15; pop r14; pop r13; pop r12; mov rsp, rbp; pop rbp; ret

quiescence_search:
    push rbp; mov rbp, rsp; push r12; push r13; push r14; push r15
    inc qword [nodes_searched]
    call evaluate
    cmp byte [side_to_move], 0; jne .negate_eval
.continue_eval:
    cmp eax, edx; jge .q_return_beta
    cmp eax, esi; jle .alpha_ok; mov esi, eax
.alpha_ok:
    mov r12d, esi; mov r13d, edx; mov r14d, eax
    call generate_tactical_moves; call score_moves
    mov r15, 0
.q_move_loop:
    mov r10, [move_list_end]; sub r10, move_list; shr r10, 2; cmp r15, r10
    jge .q_done
    call find_next_best_move
    movzx ecx, byte [r10]; movzx edx, byte [r10+1]
    call make_move
    mov rdi, 0; mov esi, r13d; neg esi; mov edx, r12d; neg edx
    call quiescence_search; neg eax
    call unmake_move; inc r15
    cmp eax, r14d; jle .q_next_move; mov r14d, eax
    cmp eax, r12d; jle .q_next_move; mov r12d, eax
    cmp r12d, r13d; jge .q_beta_cutoff
.q_next_move: jmp .q_move_loop
.negate_eval: neg eax; jmp .continue_eval
.q_beta_cutoff: mov eax, r13d; jmp .q_exit
.q_return_beta: mov eax, edx; jmp .q_exit
.q_done: mov eax, r14d
.q_exit: pop r15; pop r14; pop r13; pop r12; mov rsp, rbp; pop rbp; ret

evaluate:
    push rbx; push rcx; push rsi; push rdi
    xor edx, edx
    call evaluate_pawns; add edx, eax
    call evaluate_king_safety; add edx, eax
    call evaluate_rooks; add edx, eax
    mov rcx, 0
.eval_loop:
    cmp rcx, 64; jge .eval_done
    movzx rbx, byte [board + rcx]; cmp rbx, EMPTY; je .next_square
    mov rdi, rbx; and rdi, COLOR_MASK; and rbx, PIECE_MASK
    movsx rax, word [piece_values - 2 + rbx*2]
    mov rsi, [pst_pointers - 8 + rbx*8]
    cmp rdi, 0; je .is_white_pst
    mov r8, 63; sub r8, rcx; movsx r9, byte [rsi + r8]; neg r9; add rax, r9; jmp .add_to_score
.is_white_pst: movsx r9, byte [rsi + rcx]; add rax, r9
.add_to_score: cmp rdi, 0; je .add_val; sub edx, eax; jmp .next_square
.add_val: add edx, eax
.next_square: inc rcx; jmp .eval_loop
.eval_done: mov eax, edx; pop rdi; pop rsi; pop rcx; pop rbx; ret

score_moves:
    push r12; push r13; mov r10, move_list; mov r12, 0
.scoring_loop:
    cmp r10, [move_list_end]; jge .scoring_done
    movzx ecx, byte [r10]; movzx edx, byte [r10+1]; movzx eax, byte [board+rdx]
    cmp eax, EMPTY; jne .is_capture
    mov dword [move_scores + r12*4], 0; jmp .next_move
.is_capture:
    mov r8, rcx; mov r9, rdx
    call static_exchange_evaluation; add eax, 1000000
    mov [move_scores + r12*4], eax
.next_move: add r10, 4; inc r12; jmp .scoring_loop
.scoring_done: pop r13; pop r12; ret

static_exchange_evaluation:
    push rbx; push rcx; push rdx; push rsi; push rdi; push r12; push r13; push r14; push r15
    sub rsp, 32 
    mov r12, rsp
    mov r14, r8
    mov r15, r9
    movzx eax, byte [board + r15]
    and eax, PIECE_MASK
    movsx eax, word [piece_values - 2 + eax*2]
    mov [r12], ax
    mov edi, 1
.see_loop:
    mov al, [side_to_move]; xor al, 8; mov [side_to_move], al
    mov rsi, r15
    mov dl, [side_to_move]
    call get_least_valuable_attacker
    cmp rax, -1
    je .see_done
    movzx ecx, byte [board+rax]
    and ecx, PIECE_MASK
    movsx ecx, word [piece_values - 2 + ecx*2]
    mov [r12 + edi*2], cx
    inc edi
    mov cl, [board+rax]
    mov byte [board+r15], cl
    mov byte [board+rax], EMPTY
    jmp .see_loop
.see_done:
    mov ecx, edi
.unwind_loop:
    dec ecx
    cmp ecx, 0
    jl .unwind_done
    mov al, [board+r15]
    mov byte [board+rax], al
    movzx ebx, word [r12 + ecx*2]
    mov byte [board+r15], bl
    jmp .unwind_loop
.unwind_done:
    mov al, [side_to_move]; xor al, 8; mov [side_to_move], al
    movsx eax, word [r12]
    mov ecx, 1
.calc_see:
    cmp ecx, edi
    jge .final_see
    movsx edx, word [r12 + ecx*2]
    sub eax, edx
    inc ecx
    cmp ecx, edi
    jge .final_see
    movsx edx, word [r12 + ecx*2]
    add eax, edx
    inc ecx; jmp .calc_see
.final_see:
    add rsp, 32
    pop r15; pop r14; pop r13; pop r12; pop rdi; pop rsi; pop rdx; pop rcx; pop rbx
    ret

; Helper utility: is_move_on_board(rax=from, rbx=to) -> al (0 or 1)
; Checks for board wrap-around. Essential for knight and pawn moves.
is_move_on_board:
    push rdx
    push rcx
    mov rcx, 8
    
    mov rdi, rax
    xor rdx, rdx
    div rcx             ; from_file in rdx
    push rdx
    
    mov rdi, rbx
    xor rdx, rdx
    div rcx             ; to_file in rdx
    
    pop rcx             ; pop from_file into rcx
    sub rdx, rcx        ; diff = to_file - from_file
    
    cmp rdx, 2
    jg .move_wraps
    cmp rdx, -2
    jl .move_wraps
    
    mov rax, 1
    jmp .util_done
.move_wraps:
    xor rax, rax
.util_done:
    pop rcx
    pop rdx
    ret

;--------------------------------------------------------------------------
; check_knight_attacks(rdi: square, rsi: attacker_color) -> rax (0 or 1)
;--------------------------------------------------------------------------
check_knight_attacks:
    push rbx; push rcx; push rdx; push r8; push r9
    mov r8, rdi             ; r8 = target square
    mov r9b, sil            ; r9b = attacker color
    mov rdx, knight_offsets
    mov rcx, 8              ; 8 knight moves
.loop:
    movsx rbx, byte [rdx]
    add rbx, r8
    cmp rbx, 0
    jl .next
    cmp rbx, 64
    jge .next
    mov rax, r8
    call is_move_on_board
    test al, al
    jz .next
    movzx rax, byte [board + rbx]
    cmp rax, EMPTY
    je .next
    mov al, byte [board + rbx]
    and al, COLOR_MASK
    cmp al, r9b
    jne .next
    mov al, byte [board + rbx]
    and al, PIECE_MASK
    cmp al, W_KNIGHT
    jne .next
    mov rax, 1
    jmp .exit
.next:
    inc rdx
    dec rcx
    jnz .loop
    xor rax, rax
.exit:
    pop r9; pop r8; pop rdx; pop rcx; pop rbx
    ret

;--------------------------------------------------------------------------
; check_sliding_attacks(rdi: square, rsi: attacker_color) -> rax (0 or 1)
; Checks for rook, bishop, queen, and king attacks.
;--------------------------------------------------------------------------
check_sliding_attacks:
    push rbx; push rcx; push rdx; push r10; push r11; push r12; push r13
    mov r10, rdi            ; r10 = target square
    mov r11b, sil           ; r11b = attacker color
    ; --- Check Diagonal (Bishop/Queen) ---
    mov r12, bishop_offsets
    mov r13, 4
    call .sliding_loop
    test al, al; jnz .found
    ; --- Check Straight (Rook/Queen) ---
    mov r12, rook_offsets
    mov r13, 4
    call .sliding_loop
    test al, al; jnz .found
    ; --- Check King ---
    mov rcx, 8
    mov rdx, king_offsets
.king_loop:
    movsx rax, byte [rdx]
    add rax, r10
    cmp rax, 0; jl .next_king
    cmp rax, 64; jge .next_king
    mov cl, byte [board+rax]; and cl, PIECE_MASK; cmp cl, W_KING; jne .next_king
    mov cl, byte [board+rax]; and cl, COLOR_MASK; cmp cl, r11b; jne .next_king
    mov rax, 1; jmp .exit
.next_king:
    inc rdx; dec rcx; jnz .king_loop
.not_found:
    xor rax, rax
    jmp .exit
.found:
    mov rax, 1
.exit:
    pop r13; pop r12; pop r11; pop r10; pop rdx; pop rcx; pop rbx
    ret
; Helper for check_sliding_attacks
.sliding_loop:
    movsx rdi, byte [r12]
    mov rax, r10
.ray_loop:
    add rax, rdi
    cmp rax, 0; jl .next_dir
    cmp rax, 64; jge .next_dir
    mov rsi, rax; sub rsi, rdi; call is_move_on_board; test al, al; jz .next_dir
    mov cl, byte [board + rax]
    cmp cl, EMPTY; je .ray_loop
    mov ch, cl; and ch, COLOR_MASK; cmp ch, r11b; jne .next_dir
    and cl, PIECE_MASK
    cmp cl, W_QUEEN; je .attack_is_real
    cmp r12, bishop_offsets; je .check_bishop
    cmp cl, W_ROOK; jne .next_dir
    jmp .attack_is_real
.check_bishop:
    cmp cl, W_BISHOP; jne .next_dir
.attack_is_real:
    mov al, 1; ret
.next_dir:
    inc r12; dec r13; jnz .sliding_loop
    mov al, 0; ret

;--------------------------------------------------------------------------
; is_square_attacked(rdi: square, rsi: attacker_color) -> rax (0 or 1)
;--------------------------------------------------------------------------
is_square_attacked:
    push rbx; push r12; push r13; push r14
    mov r12, rdi; mov r13b, sil
    mov r14, r13; xor r14, 8 ; opponent_color
    cmp r14b, 0; jne .check_black_pawn_attack
    mov rax, r12; sub rax, 9; call .check_pawn_attack; test al, al; jnz .attack_found
    mov rax, r12; sub rax, 7; call .check_pawn_attack; test al, al; jnz .attack_found
    jmp .check_non_pawn
.check_black_pawn_attack:
    mov rax, r12; add rax, 7; call .check_pawn_attack; test al, al; jnz .attack_found
    mov rax, r12; add rax, 9; call .check_pawn_attack; test al, al; jnz .attack_found
.check_non_pawn:
    mov rdi, r12; mov rsi, r13; call check_knight_attacks; test al, al; jnz .attack_found
    mov rdi, r12; mov rsi, r13; call check_sliding_attacks; test al, al; jnz .attack_found
.no_attack:
    xor rax, rax; jmp .done
.attack_found:
    mov rax, 1
.done:
    pop r14; pop r13; pop r12; pop rbx; ret
; Helper for is_square_attacked
.check_pawn_attack:
    cmp rax, 0; jl .pawn_fail; cmp rax, 64; jge .pawn_fail
    mov rbx, r12; mov rsi, rax; call is_move_on_board; test al, al; jz .pawn_fail
    movzx rbx, byte [board + rax]; cmp rbx, EMPTY; je .pawn_fail
    mov cl, r13b; or cl, W_PAWN; cmp bl, cl; jne .pawn_fail
    mov al, 1; ret
.pawn_fail:
    mov al, 0; ret

;--------------------------------------------------------------------------
; is_king_in_check() -> rax (0 or 1)
; Uses the current side_to_move to find its king and see if it's attacked.
;--------------------------------------------------------------------------
is_king_in_check:
    push rdi; push rsi; push rbx; push rcx
    movzx rsi, byte [side_to_move]
    mov cl, sil; or cl, W_KING
    mov rbx, 0
.find_loop:
    cmp byte [board + rbx], cl; je .found_king
    inc rbx; cmp rbx, 64; jne .find_loop
.found_king:
    mov rdi, rbx; mov rsi, [side_to_move]; xor rsi, 8
    call is_square_attacked
    pop rcx; pop rbx; pop rsi; pop rdi
    ret

; Dummy placeholders for other functions until they are implemented
get_least_valuable_attacker: ret
is_square_attacked_by_opponent: ret
evaluate_pawns: ret
evaluate_king_safety: ret
evaluate_rooks: ret
is_file_open: ret
is_passed: ret
probe_tablebase: mov eax, 100; ret

board_to_fen: ret
load_opening_book: ret
find_book_move: xor rax, rax; ret
weighted_choice: ret
compute_zobrist_hash: ret
initialize_zobrist_keys:
    mov rdi, zobrist_keys
    mov rcx, 769 
.rand_loop:
    push rcx
    call lcg_rand
    mov [rdi], rax
    add rdi, 8
    pop rcx
    loop .rand_loop
    ret

lcg_rand:
    mov rax, [lcg_seed]
    mov rbx, 6364136223846793005
    mul rbx
    add rax, 1442695040888963407
    mov [lcg_seed], rax
    ret

find_next_best_move:
    push rsi; push rdi; mov ebx, -2000000000; mov rax, -1; mov rcx, 0
.find_loop:
    mov rdi, [move_list_end]; mov rsi, move_list; sub rdi, rsi; shr rdi, 2
    cmp rcx, rdi; jge .find_done; mov edx, [move_scores + rcx*4]; cmp edx, ebx
    jle .find_next; mov ebx, edx; mov rax, rcx
.find_next: inc rcx; jmp .find_loop
.find_done: mov dword [move_scores + rax*4], -2000000000; mov r10, move_list
    lea r10, [r10 + rax*4]; pop rdi; pop rsi; ret

generate_tactical_moves:
    mov rbx, move_list; mov [move_list_end], rbx
    call generate_moves
    ret

generate_moves:
    mov rbx, move_list; mov [move_list_end], rbx; mov r11b, [side_to_move]; mov rcx, 0
.gen_loop:
    cmp rcx, 64; jge .gen_done; movzx rdi, byte [board + rcx]; cmp rdi, EMPTY
    je .next_gen_square; mov rsi, rdi; and rsi, COLOR_MASK; cmp sil, r11b
    jne .next_gen_square; and edi, PIECE_MASK; cmp edi, W_PAWN; je .gen_pawn
    cmp edi, W_KNIGHT; je .gen_knight; cmp edi, W_BISHOP; je .gen_bishop
    cmp edi, W_ROOK; je .gen_rook; cmp edi, W_QUEEN; je .gen_queen
    cmp edi, W_KING; je .gen_king; jmp .next_gen_square
.gen_pawn: call generate_pawn_moves; jmp .next_gen_square
.gen_knight: call generate_knight_moves; jmp .next_gen_square
.gen_bishop: call generate_sliding_moves_bishop; jmp .next_gen_square
.gen_rook: call generate_sliding_moves_rook; jmp .next_gen_square
.gen_queen: call generate_sliding_moves_bishop; call generate_sliding_moves_rook; jmp .next_gen_square
.gen_king: call generate_king_moves; jmp .next_gen_square
.next_gen_square: inc rcx; jmp .gen_loop
.gen_done: ret

generate_pawn_moves:
    push r8; push r9; push r10; push r11
    mov r8, rcx                 ; from square
    mov al, [side_to_move]
    test al, al; jz .white_pawn

; --- BLACK PAWNS ---
.black_pawn:
    ; 1. Single Push
    mov r10, r8; sub r10, 8;
    cmp r10, 0; jl .black_captures
    cmp byte [board+r10], EMPTY; jne .black_captures
    ADD_MOVE r8b, r10b
    ; 2. Double Push
    cmp r8, 48; jl .black_captures
    cmp r8, 56; jge .black_captures
    mov r10, r8; sub r10, 16
    cmp byte [board+r10], EMPTY; jne .black_captures
    ADD_MOVE r8b, r10b

.black_captures:
    ; 3. Capture West
    mov r10, r8; sub r10, 9
    cmp r10, 0; jl .black_capture_east
    mov rax, r8; mov rbx, r10; call is_move_on_board; test al, al; jz .black_capture_east
    movzx r11, byte [board+r10]; cmp r11, EMPTY; je .black_capture_east
    mov r11b, [board+r10]; and r11b, COLOR_MASK; cmp r11b, 0; jne .black_capture_east
    ADD_MOVE r8b, r10b

.black_capture_east:
    ; 4. Capture East
    mov r10, r8; sub r10, 7
    cmp r10, 0; jl .pawn_done
    mov rax, r8; mov rbx, r10; call is_move_on_board; test al, al; jz .pawn_done
    movzx r11, byte [board+r10]; cmp r11, EMPTY; je .pawn_done
    mov r11b, [board+r10]; and r11b, COLOR_MASK; cmp r11b, 0; jne .pawn_done
    ADD_MOVE r8b, r10b
    jmp .pawn_done

; --- WHITE PAWNS ---
.white_pawn:
    ; 1. Single Push
    mov r10, r8; add r10, 8
    cmp r10, 64; jge .white_captures
    cmp byte [board+r10], EMPTY; jne .white_captures
    ADD_MOVE r8b, r10b
    ; 2. Double Push
    cmp r8, 8; jl .white_captures
    cmp r8, 16; jge .white_captures
    mov r10, r8; add r10, 16
    cmp byte [board+r10], EMPTY; jne .white_captures
    ADD_MOVE r8b, r10b

.white_captures:
    ; 3. Capture West
    mov r10, r8; add r10, 7
    cmp r10, 64; jge .white_capture_east
    mov rax, r8; mov rbx, r10; call is_move_on_board; test al, al; jz .white_capture_east
    movzx r11, byte [board+r10]; cmp r11, EMPTY; je .white_capture_east
    mov r11b, [board+r10]; and r11b, COLOR_MASK; cmp r11b, 8; jne .white_capture_east
    ADD_MOVE r8b, r10b

.white_capture_east:
    ; 4. Capture East
    mov r10, r8; add r10, 9
    cmp r10, 64; jge .pawn_done
    mov rax, r8; mov rbx, r10; call is_move_on_board; test al, al; jz .pawn_done
    movzx r11, byte [board+r10]; cmp r11, EMPTY; je .pawn_done
    mov r11b, [board+r10]; and r11b, COLOR_MASK; cmp r11b, 8; jne .pawn_done
    ADD_MOVE r8b, r10b

.pawn_done:
    pop r11; pop r10; pop r9; pop r8
    ret

generate_knight_moves:
    mov r8, rcx; mov r9, knight_offsets; mov r12, 8
.knight_loop:
    mov r10, r8; movsx rdx, byte [r9]; add r10, rdx
    cmp r10, 0; jl .next_knight_move; cmp r10, 64; jge .next_knight_move
    mov rax, r8; mov rbx, 8; xor rdx, rdx; div rbx; mov rbx, rdx
    mov rax, r10; mov rdi, 8; xor rdx, rdx; div rdi; mov rdi, rdx
    sub rbx, rdi; cmp rbx, -2; jle .next_knight_move; cmp rbx, 2; jge .next_knight_move
    movzx r11, byte [board+r10]; cmp r11, EMPTY; je .knight_add_move
    mov r11b, [side_to_move]; xor r11b, 8; movzx rax, byte [board+r10]
    and al, COLOR_MASK; cmp al, r11b; jne .next_knight_move
.knight_add_move: ADD_MOVE r8b, r10b
.next_knight_move: inc r9; dec r12; jnz .knight_loop; ret

generate_king_moves:
    mov r8, rcx; mov r9, king_offsets; mov r12, 8
.king_loop:
    mov r10, r8; movsx rdx, byte [r9]; add r10, rdx
    cmp r10, 0; jl .next_king_move; cmp r10, 64; jge .next_king_move
    mov rax, r8; mov rbx, 8; xor rdx, rdx; div rbx; mov rbx, rdx
    mov rax, r10; mov rdi, 8; xor rdx, rdx; div rdi; mov rdi, rdx
    sub rbx, rdi; cmp rbx, -1; jle .next_king_move; cmp rbx, 1; jge .next_king_move
    movzx r11, byte [board+r10]; cmp r11, EMPTY; je .king_add_move
    mov r11b, [side_to_move]; xor r11b, 8; movzx rax, byte [board+r10]
    and al, COLOR_MASK; cmp al, r11b; jne .next_king_move
.king_add_move: ADD_MOVE r8b, r10b
.next_king_move: inc r9; dec r12; jnz .king_loop; ret

generate_sliding_moves_bishop: mov r12, bishop_offsets; mov r13, 4; call generate_sliding_moves; ret
generate_sliding_moves_rook: mov r12, rook_offsets; mov r13, 4; call generate_sliding_moves; ret
generate_sliding_moves:
    push r8; push r9; push r10; push r11; push r12; push r13; mov r9, r12
.dir_loop:
    mov r8, rcx; movsx r10, byte [r9]
.slide_loop:
    add r8, r10; cmp r8, 0; jl .next_dir; cmp r8, 64; jge .next_dir
    movzx rbx, byte [board+r8]; cmp rbx, EMPTY; je .empty_square
    mov r11b, [side_to_move]; xor r11b, 8; movzx rax, byte [board+r8]
    and al, COLOR_MASK; cmp al, r11b; jne .next_dir
    ADD_MOVE cl, r8b; jmp .next_dir
.empty_square: ADD_MOVE cl, r8b; jmp .slide_loop
.next_dir: inc r9; dec r13; jnz .dir_loop
    pop r13; pop r12; pop r11; pop r10; pop r9; pop r8; ret

make_move:
    push r8; push r9; movzx rax, byte [board+r9]; push rax; movzx rax, byte [board+r8]
    push rax; mov cl, byte [board+r8]; mov byte [board+r9], cl; mov byte [board+r8], EMPTY
    mov al, [side_to_move]; xor al, 8; mov [side_to_move], al; ret

unmake_move:
    pop rax; mov [r8], al; pop rax; mov [r9], al; mov al, [side_to_move]
    xor al, 8; mov [side_to_move], al; pop r9; pop r8; ret

print_best_move:
    push rax; push rdi; push rsi; push rdx
    mov rax, 1; mov rdi, 1; mov rsi, bestmove_msg; mov rdx, len_bestmove_msg; syscall
    movzx rbx, word [root_best_move]
    movzx rcx, bl; shl rcx, 1; mov rsi, square_to_an; add rsi, rcx
    mov rax, 1; mov rdi, 1; mov rdx, 2; syscall
    movzx rcx, bh; shl rcx, 1; mov rsi, square_to_an; add rsi, rcx
    mov rax, 1; mov rdi, 1; mov rdx, 2; syscall
    mov rax, 1; mov rdi, 1; mov rsi, newline; mov rdx, 1; syscall
    pop rdx; pop rsi; pop rdi; pop rax; ret

initialize_board:
    mov rsi, initial_board; mov rdi, board; mov rcx, 64; rep movsb
    mov byte [side_to_move], 0; ret
