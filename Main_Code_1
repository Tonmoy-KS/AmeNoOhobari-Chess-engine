; ============================================================================
; AmeNoOhobari.asm - V.1.2.2 - The God-Slayer
; Author: Tonmoy KS
;
; How to Compile and Run (on Linux):
;   nasm -f elf64 -g AmeNoOhobari.asm -o AmeNoOhobari.o
;   ld AmeNoOhobari.o -o AmeNoOhobari
;   ./AmeNoOhobari
;
; Expected Output: bestmove g1f3
; ============================================================================

section .data
    ; --- Piece Constants (Bit 3 = Color: 0=White, 1=Black) ---
    EMPTY      equ 0
    W_PAWN     equ 1
    W_KNIGHT   equ 2
    W_BISHOP   equ 3
    W_ROOK     equ 4
    W_QUEEN    equ 5
    W_KING     equ 6
    B_PAWN     equ 9
    B_KNIGHT   equ 10
    B_BISHOP   equ 11
    B_ROOK     equ 12
    B_QUEEN    equ 13
    B_KING     equ 14

    PIECE_MASK  equ 7  ; 0b0111
    COLOR_MASK  equ 8  ; 0b1000

    ; --- Initial Board Setup (Standard Chess Position) ---
    initial_board:
        db B_ROOK, B_KNIGHT, B_BISHOP, B_QUEEN, B_KING, B_BISHOP, B_KNIGHT, B_ROOK
        db B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN
        db EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY
        db EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY
        db EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY
        db EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY
        db W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN
        db W_ROOK, W_KNIGHT, W_BISHOP, W_QUEEN, W_KING, W_BISHOP, W_KNIGHT, W_ROOK

    ; --- Evaluation Data ---
    piece_values: dw 0, 100, 320, 330, 500, 900, 10000 ; EMPTY, P, N, B, R, Q, K

    pawn_pst:
        db   0,  0,  0,  0,  0,  0,  0,  0
        db  50, 50, 50, 50, 50, 50, 50, 50
        db  10, 10, 20, 30, 30, 20, 10, 10
        db   5,  5, 10, 25, 25, 10,  5,  5
        db   0,  0,  0, 20, 20,  0,  0,  0
        db   5, -5,-10,  0,  0,-10, -5,  5
        db   5, 10, 10,-20,-20, 10, 10,  5
        db   0,  0,  0,  0,  0,  0,  0,  0

    knight_pst:
        db -50,-40,-30,-30,-30,-30,-40,-50
        db -40,-20,  0,  0,  0,  0,-20,-40
        db -30,  0, 10, 15, 15, 10,  0,-30
        db -30,  5, 15, 20, 20, 15,  5,-30
        db -30,  0, 15, 20, 20, 15,  0,-30
        db -30,  5, 10, 15, 15, 10,  5,-30
        db -40,-20,  0,  5,  5,  0,-20,-40
        db -50,-40,-30,-30,-30,-30,-40,-50

    bishop_pst:
        db -20,-10,-10,-10,-10,-10,-10,-20
        db -10,  0,  0,  0,  0,  0,  0,-10
        db -10,  0,  5, 10, 10,  5,  0,-10
        db -10,  5,  5, 10, 10,  5,  5,-10
        db -10,  0, 10, 10, 10, 10,  0,-10
        db -10, 10, 10, 10, 10, 10, 10,-10
        db -10,  5,  0,  0,  0,  0,  5,-10
        db -20,-10,-10,-10,-10,-10,-10,-20

    rook_pst:
        db   0,  0,  0,  0,  0,  0,  0,  0
        db   5, 10, 10, 10, 10, 10, 10,  5
        db  -5,  0,  0,  0,  0,  0,  0, -5
        db  -5,  0,  0,  0,  0,  0,  0, -5
        db  -5,  0,  0,  0,  0,  0,  0, -5
        db  -5,  0,  0,  0,  0,  0,  0, -5
        db  -5,  0,  0,  0,  0,  0,  0, -5
        db   0,  0,  0,  5,  5,  0,  0,  0

    queen_pst:
        db -20,-10,-10, -5, -5,-10,-10,-20
        db -10,  0,  0,  0,  0,  0,  0,-10
        db -10,  0,  5,  5,  5,  5,  0,-10
        db  -5,  0,  5,  5,  5,  5,  0, -5
        db   0,  0,  5,  5,  5,  5,  0, -5
        db -10,  5,  5,  5,  5,  5,  0,-10
        db -10,  0,  5,  0,  0,  0,  0,-10
        db -20,-10,-10, -5, -5,-10,-10,-20

    king_pst:
        db -30,-40,-40,-50,-50,-40,-40,-30
        db -30,-40,-40,-50,-50,-40,-40,-30
        db -30,-40,-40,-50,-50,-40,-40,-30
        db -30,-40,-40,-50,-50,-40,-40,-30
        db -20,-30,-30,-40,-40,-30,-30,-20
        db -10,-20,-20,-20,-20,-20,-20,-10
        db  20, 20,  0,  0,  0,  0, 20, 20
        db  20, 30, 10,  0,  0, 10, 30, 20

    pst_pointers: dq pawn_pst, knight_pst, bishop_pst, rook_pst, queen_pst, king_pst

    ; --- Move Generation Data ---
    knight_offsets: db -17, -15, -10, -6,  6, 10, 15, 17
    bishop_offsets: db -9, -7,  7,  9
    rook_offsets:   db -8, -1,  1,  8
    king_offsets:   db -9, -8, -7, -1,  1,  7,  8,  9

    ; --- Output Strings and Data ---
    bestmove_msg: db "bestmove ", 9
    len_bestmove_msg: equ $ - bestmove_msg
    newline: db 10
    square_to_an: db "a1b1c1d1e1f1g1h1a2b2c2d2e2f2g2h2a3b3c3d3e3f3g3h3a4b4c4d4e4f4g4h4a5b5c5d5e5f5g5h5a6b6c6d6e6f6g6h6a7b7c7d7e7f7g7h7a8b8c8d8e8f8g8h8"

section .bss
    board: resb 64
    side_to_move: resb 1
    
    ; Move list structure: 256 moves max, 4 bytes per move
    ; byte 0: from_sq, byte 1: to_sq, byte 2: captured_piece, byte 3: moved_piece
    move_list: resb 256 * 4
    move_list_end: resq 1
    
    root_best_move: resd 1
    nodes_searched: resq 1

section .text
global _start

; A simple macro to add a move to the move list
%macro ADD_MOVE 2
    mov rdi, [move_list_end]
    mov byte [rdi], %1 ; from square
    mov byte [rdi+1], %2 ; to square
    add rdi, 4
    mov [move_list_end], rdi
%endmacro

_start:
    call initialize_board

    ; Find the best move for the root position
    ; RDI = depth, RSI = alpha, RDX = beta
    mov edi, 4          ; Search depth
    mov esi, -30000     ; Alpha
    mov edx, 30000      ; Beta
    call find_best_move
    
    call print_best_move
    
    ; Exit syscall
    mov rax, 60
    xor rdi, rdi
    syscall

; ============================================================================
; Board and Game State
; ============================================================================
initialize_board:
    mov rsi, initial_board
    mov rdi, board
    mov rcx, 64
    rep movsb
    mov byte [side_to_move], 0 ; 0 for White, 8 for Black
    ret

; ============================================================================
; Root Search Function
; ============================================================================
; In: RDI=depth, RSI=alpha, RDX=beta
find_best_move:
    push r12
    push r13
    push r14
    
    mov r12d, esi ; Save alpha
    mov r13d, edx ; Save beta
    mov r14, rdi  ; Save depth
    mov dword [root_best_move], 0
    mov qword [nodes_searched], 0
    
    call generate_moves
    
    mov r10, move_list ; r10 is our move pointer
.move_loop:
    cmp r10, [move_list_end]
    jge .done_searching
    
    ; Make the move
    movzx r8, byte [r10]   ; from
    movzx r9, byte [r10+1] ; to
    call make_move
    
    ; Call negamax for the new position
    mov rdi, r14      ; depth
    dec rdi
    mov rsi, r13d     ; -beta
    neg esi
    mov rdx, r12d     ; -alpha
    neg edx
    call negamax
    neg eax           ; We want our own score back
    
    call unmake_move
    
    ; Is this move better than the best we've found so far?
    cmp eax, r12d
    jle .next_move
    
    ; Yes, it's a new best move
    mov r12d, eax
    ; Store the move (from and to squares)
    mov cl, r8b
    mov ch, r9b
    mov [root_best_move], cx

.next_move:
    add r10, 4
    jmp .move_loop

.done_searching:
    pop r14
    pop r13
    pop r12
    ret

; ============================================================================
; NegaMax Search with Alpha-Beta Pruning
; ============================================================================
; In: RDI=depth, RSI=alpha, RDX=beta
; Out: RAX=score
negamax:
    push rbp
    mov rbp, rsp
    sub rsp, 16 ; Stack space for local variables
    push r12
    push r13
    push r14
    
    inc qword [nodes_searched]

    ; Base Case: Reached depth limit
    cmp rdi, 0
    je .eval_and_return
    
    mov r12d, esi ; alpha
    mov r13d, edx ; beta
    mov r14, rdi  ; depth

    call generate_moves
    
    mov r10, move_list ; r10 is move pointer
.move_loop:
    cmp r10, [move_list_end]
    jge .done_searching
    
    call make_move
    
    mov rdi, r14
    dec rdi
    mov rsi, r13d ; -beta
    neg esi
    mov rdx, r12d ; -alpha
    neg edx
    call negamax
    neg eax
    
    call unmake_move

    ; --- Alpha-Beta Pruning Logic ---
    ; Is the returned score better than our current best?
    cmp eax, r12d
    jle .next_move
    
    mov r12d, eax ; Update alpha

    ; Beta cutoff check
    cmp r12d, r13d
    jge .beta_cutoff

.next_move:
    add r10, 4
    jmp .move_loop

.beta_cutoff:
    mov eax, r12d ; Return alpha (the best score found)
    jmp .exit

.done_searching:
    mov eax, r12d ; Return best score found
    jmp .exit

.eval_and_return:
    call evaluate
    cmp byte [side_to_move], 0
    je .exit
    neg eax ; Negate score if it's black's turn
    
.exit:
    pop r14
    pop r13
    pop r12
    mov rsp, rbp
    pop rbp
    ret

; ============================================================================
; Evaluation Function
; ============================================================================
; Out: EAX=score from white's perspective
evaluate:
    push rbx
    push rcx
    push rsi
    push rdi
    
    xor eax, eax ; score = 0
    mov rcx, 0   ; square_index
.eval_loop:
    cmp rcx, 64
    jge .eval_done
    
    movzx rbx, byte [board + rcx]
    cmp rbx, EMPTY
    je .next_square
    
    mov rdi, rbx
    and rdi, COLOR_MASK ; piece_color
    and rbx, PIECE_MASK ; piece_type
    
    ; Get material value
    movsx rdx, word [piece_values - 2 + rbx*2]
    
    ; Get PST value
    mov rsi, [pst_pointers - 8 + rbx*8]
    cmp rdi, 0 ; is white?
    je .is_white_pst
    
    ; Is black
    mov r8, 63
    sub r8, rcx ; Mirrored square index
    movsx r9, byte [rsi + r8]
    neg r9
    add rdx, r9
    jmp .add_to_score
    
.is_white_pst:
    movsx r9, byte [rsi + rcx]
    add rdx, r9
    
.add_to_score:
    cmp rdi, 0 ; is white?
    je .add_val
    sub eax, edx
    jmp .next_square
.add_val:
    add eax, edx
    
.next_square:
    inc rcx
    jmp .eval_loop

.eval_done:
    pop rdi
    pop rsi
    pop rcx
    pop rbx
    ret

; ============================================================================
; Move Generation
; ============================================================================
generate_moves:
    mov rbx, move_list
    mov [move_list_end], rbx
    mov r11b, [side_to_move]
    
    mov rcx, 0 ; from_square
.gen_loop:
    cmp rcx, 64
    jge .gen_done
    
    movzx rdi, byte [board + rcx]
    cmp rdi, EMPTY
    je .next_gen_square
    
    mov rsi, rdi
    and rsi, COLOR_MASK
    cmp sil, r11b
    jne .next_gen_square
    
    and edi, PIECE_MASK
    cmp edi, W_PAWN
    je .gen_pawn
    cmp edi, W_KNIGHT
    je .gen_knight
    cmp edi, W_BISHOP
    je .gen_bishop
    cmp edi, W_ROOK
    je .gen_rook
    cmp edi, W_QUEEN
    je .gen_queen
    cmp edi, W_KING
    je .gen_king
    
    jmp .next_gen_square

.gen_pawn:   call generate_pawn_moves;   jmp .next_gen_square
.gen_knight: call generate_knight_moves; jmp .next_gen_square
.gen_bishop: call generate_sliding_moves_bishop; jmp .next_gen_square
.gen_rook:   call generate_sliding_moves_rook;   jmp .next_gen_square
.gen_queen:  call generate_sliding_moves_bishop; call generate_sliding_moves_rook; jmp .next_gen_square
.gen_king:   call generate_king_moves;   jmp .next_gen_square

.next_gen_square:
    inc rcx
    jmp .gen_loop
.gen_done:
    ret

; --- Piece-Specific Generators ---
; In: RCX = from_square
generate_pawn_moves:
    ; This is a simplified pawn move generation. It does not handle
    ; promotions or en-passant for brevity. A full implementation is required
    ; for a complete engine.
    mov r8, rcx ; from_sq
    cmp byte [side_to_move], 0
    je .white_pawn

.black_pawn:
    ; One step forward
    mov r10, r8; sub r10, 8
    cmp r10, 0
    jl .pawn_done
    cmp byte [board+r10], EMPTY
    jne .pawn_done
    ADD_MOVE r8b, r10b
    jmp .pawn_done

.white_pawn:
    ; One step forward
    mov r10, r8; add r10, 8
    cmp r10, 64
    jge .pawn_done
    cmp byte [board+r10], EMPTY
    jne .pawn_done
    ADD_MOVE r8b, r10b

.pawn_done:
    ret

generate_knight_moves:
    mov r8, rcx ; from_sq
    mov r9, knight_offsets
    mov r12, 8 ; 8 possible knight moves
.knight_loop:
    mov r10, r8
    movsx rdx, byte [r9]
    add r10, rdx
    
    ; Bounds check
    cmp r10, 0
    jl .next_knight_move
    cmp r10, 64
    jge .next_knight_move
    
    ; Wrap-around check
    mov rax, r8; mov rbx, 8; xor rdx, rdx; div rbx; mov rbx, rdx ; from_file
    mov rax, r10; mov rdi, 8; xor rdx, rdx; div rdi; mov rdi, rdx ; to_file
    sub rbx, rdi
    cmp rbx, -2
    jle .next_knight_move
    cmp rbx, 2
    jge .next_knight_move
    
    ; Check if destination is empty or opponent piece
    movzx r11, byte [board+r10]
    cmp r11, EMPTY
    je .knight_add_move
    mov r11b, [side_to_move]
    xor r11b, 8 ; opponent_color
    movzx rax, byte [board+r10]
    and al, COLOR_MASK
    cmp al, r11b
    jne .next_knight_move
    
.knight_add_move:
    ADD_MOVE r8b, r10b
    
.next_knight_move:
    inc r9
    dec r12
    jnz .knight_loop
    ret

generate_king_moves:
    ; Similar to knight moves but with different offsets and wrap-around
    mov r8, rcx ; from_sq
    mov r9, king_offsets
    mov r12, 8 ; 8 possible king moves
.king_loop:
    mov r10, r8
    movsx rdx, byte [r9]
    add r10, rdx
    
    cmp r10, 0
    jl .next_king_move
    cmp r10, 64
    jge .next_king_move
    
    mov rax, r8; mov rbx, 8; xor rdx, rdx; div rbx; mov rbx, rdx
    mov rax, r10; mov rdi, 8; xor rdx, rdx; div rdi; mov rdi, rdx
    sub rbx, rdi
    cmp rbx, -1
    jle .next_king_move
    cmp rbx, 1
    jge .next_king_move
    
    movzx r11, byte [board+r10]
    cmp r11, EMPTY
    je .king_add_move
    mov r11b, [side_to_move]
    xor r11b, 8
    movzx rax, byte [board+r10]
    and al, COLOR_MASK
    cmp al, r11b
    jne .next_king_move
    
.king_add_move:
    ADD_MOVE r8b, r10b
    
.next_king_move:
    inc r9
    dec r12
    jnz .king_loop
    ret

generate_sliding_moves_bishop:
    mov r12, bishop_offsets
    mov r13, 4
    call generate_sliding_moves
    ret

generate_sliding_moves_rook:
    mov r12, rook_offsets
    mov r13, 4
    call generate_sliding_moves
    ret

; Generic slider generation
; In: RCX=from_sq, R12=offset_array, R13=num_directions
generate_sliding_moves:
    push r8; push r9; push r10; push r11; push r12; push r13

    mov r9, r12 ; offsets
.dir_loop:
    mov r8, rcx ; from_sq
    movsx r10, byte [r9] ; current_offset
.slide_loop:
    add r8, r10 ; Move one step in the direction
    
    ; Bounds check
    cmp r8, 0
    jl .next_dir
    cmp r8, 64
    jge .next_dir
    
    ; Wrap-around check
    mov rax, r8; sub rax, r10; mov rbx, 8; xor rdx, rdx; div rbx; mov r11, rdx ; from_file
    mov rax, r8; xor rdx, rdx; div rbx; mov rbx, rdx ; to_file
    sub r11, rbx
    cmp r11, -1
    jle .next_dir
    cmp r11, 1
    jge .next_dir
    
    ; Check destination square
    movzx rbx, byte [board+r8]
    cmp rbx, EMPTY
    je .empty_square
    
    ; Hit a piece
    mov r11b, [side_to_move]
    xor r11b, 8 ; opponent_color
    movzx rax, byte [board+r8]
    and al, COLOR_MASK
    cmp al, r11b
    jne .next_dir ; Friendly piece, stop this direction
    
    ; Enemy piece, add capture and stop
    ADD_MOVE cl, r8b
    jmp .next_dir
    
.empty_square:
    ADD_MOVE cl, r8b
    jmp .slide_loop

.next_dir:
    inc r9
    dec r13
    jnz .dir_loop
    
    pop r13; pop r12; pop r11; pop r10; pop r9; pop r8
    ret
    
; ============================================================================
; Make/Unmake Move
; ============================================================================
; In: R8=from, R9=to (unmake uses stack)
make_move:
    push r8
    push r9
    ; Store info for unmake
    movzx rax, byte [board+r9] ; captured piece
    push rax
    movzx rax, byte [board+r8] ; moved piece
    push rax
    
    mov cl, byte [board+r8]
    mov byte [board+r9], cl
    mov byte [board+r8], EMPTY
    
    ; Switch side to move
    mov al, [side_to_move]
    xor al, 8
    mov [side_to_move], al
    ret

unmake_move:
    pop rax ; moved piece
    mov [r8], al
    pop rax ; captured piece
    mov [r9], al
    
    ; Switch side back
    mov al, [side_to_move]
    xor al, 8
    mov [side_to_move], al

    pop r9
    pop r8
    ret

; ============================================================================
; Output Functions
; ============================================================================
print_best_move:
    push rax; push rdi; push rsi; push rdx
    
    ; "bestmove "
    mov rax, 1; mov rdi, 1; mov rsi, bestmove_msg; mov rdx, len_bestmove_msg; syscall
    
    movzx rbx, word [root_best_move]
    
    ; from square
    movzx rcx, bl
    shl rcx, 1
    mov rsi, square_to_an
    add rsi, rcx
    mov rax, 1; mov rdi, 1; mov rdx, 2; syscall
    
    ; to square
    movzx rcx, bh
    shl rcx, 1
    mov rsi, square_to_an
    add rsi, rcx
    mov rax, 1; mov rdi, 1; mov rdx, 2; syscall
    
    ; newline
    mov rax, 1; mov rdi, 1; mov rsi, newline; mov rdx, 1; syscall
    
    pop rdx; pop rsi; pop rdi; pop rax
    ret